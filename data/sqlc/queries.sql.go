// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const CreateEntry = `-- name: CreateEntry :one
INSERT INTO entries (
    id,
    project_id,
    creator_id,
    content,
    duration_ms,
    started_at,
    ended_at,
    entry_type,
    is_billable
) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING id,
          project_id,
          creator_id,
          content,
          duration_ms,
          started_at,
          ended_at,
          entry_type,
          is_billable,
          created_at,
          updated_at
`

type CreateEntryParams struct {
	ID         string
	ProjectID  int64
	CreatorID  sql.NullInt64
	Content    string
	DurationMs int64
	StartedAt  sql.NullInt64
	EndedAt    sql.NullInt64
	EntryType  string
	IsBillable int64
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, CreateEntry,
		arg.ID,
		arg.ProjectID,
		arg.CreatorID,
		arg.Content,
		arg.DurationMs,
		arg.StartedAt,
		arg.EndedAt,
		arg.EntryType,
		arg.IsBillable,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatorID,
		&i.Content,
		&i.DurationMs,
		&i.StartedAt,
		&i.EndedAt,
		&i.EntryType,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateProject = `-- name: CreateProject :one
INSERT INTO projects (name, company, is_hidden)
VALUES (?1, ?2, ?3)
RETURNING id,
          name,
          company,
          is_hidden,
          position,
          created_at,
          updated_at
`

type CreateProjectParams struct {
	Name     string
	Company  sql.NullString
	IsHidden int64
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, CreateProject, arg.Name, arg.Company, arg.IsHidden)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.IsHidden,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteEntry = `-- name: DeleteEntry :exec
DELETE FROM entries
WHERE id = ?1
`

func (q *Queries) DeleteEntry(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, DeleteEntry, id)
	return err
}

const DeleteEntryTags = `-- name: DeleteEntryTags :exec
DELETE FROM entry_tags
WHERE entry_id = ?1
`

func (q *Queries) DeleteEntryTags(ctx context.Context, entryID string) error {
	_, err := q.db.ExecContext(ctx, DeleteEntryTags, entryID)
	return err
}

const DeleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = ?1
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteProject, id)
	return err
}

const DeleteTimer = `-- name: DeleteTimer :exec
DELETE FROM timers
WHERE project_id = ?1
`

func (q *Queries) DeleteTimer(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteTimer, projectID)
	return err
}

const GetEntry = `-- name: GetEntry :one
SELECT id,
       project_id,
       creator_id,
       content,
       duration_ms,
       started_at,
       ended_at,
       entry_type,
       is_billable,
       created_at,
       updated_at
FROM entries
WHERE id = ?1
`

func (q *Queries) GetEntry(ctx context.Context, id string) (Entry, error) {
	row := q.db.QueryRowContext(ctx, GetEntry, id)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatorID,
		&i.Content,
		&i.DurationMs,
		&i.StartedAt,
		&i.EndedAt,
		&i.EntryType,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPerson = `-- name: GetPerson :one

SELECT id,
       email,
       name,
       created_at,
       updated_at
FROM people
WHERE id = ?1
`

// People
func (q *Queries) GetPerson(ctx context.Context, id int64) (Person, error) {
	row := q.db.QueryRowContext(ctx, GetPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPersonByEmail = `-- name: GetPersonByEmail :one
SELECT id,
       email,
       name,
       created_at,
       updated_at
FROM people
WHERE email = ?1 COLLATE NOCASE
`

func (q *Queries) GetPersonByEmail(ctx context.Context, email string) (Person, error) {
	row := q.db.QueryRowContext(ctx, GetPersonByEmail, email)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetProject = `-- name: GetProject :one
SELECT id,
       name,
       company,
       is_hidden,
       position,
       created_at,
       updated_at
FROM projects
WHERE id = ?1
`

func (q *Queries) GetProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, GetProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.IsHidden,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetProjectByName = `-- name: GetProjectByName :one
SELECT id,
       name,
       company,
       is_hidden,
       position,
       created_at,
       updated_at
FROM projects
WHERE name = ?1 COLLATE NOCASE
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRowContext(ctx, GetProjectByName, name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.IsHidden,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetTimer = `-- name: GetTimer :one

SELECT project_id,
       started_at,
       created_at,
       updated_at
FROM timers
WHERE project_id = ?1
`

// Timers
func (q *Queries) GetTimer(ctx context.Context, projectID int64) (Timer, error) {
	row := q.db.QueryRowContext(ctx, GetTimer, projectID)
	var i Timer
	err := row.Scan(
		&i.ProjectID,
		&i.StartedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const InsertEntryTag = `-- name: InsertEntryTag :exec
INSERT INTO entry_tags (entry_id, tag)
VALUES (?1, ?2)
ON CONFLICT(entry_id, tag) DO NOTHING
`

type InsertEntryTagParams struct {
	EntryID string
	Tag     string
}

func (q *Queries) InsertEntryTag(ctx context.Context, arg InsertEntryTagParams) error {
	_, err := q.db.ExecContext(ctx, InsertEntryTag, arg.EntryID, arg.Tag)
	return err
}

const ListAllTags = `-- name: ListAllTags :many
SELECT DISTINCT tag
FROM entry_tags
ORDER BY tag
`

func (q *Queries) ListAllTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, ListAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEntriesByProject = `-- name: ListEntriesByProject :many

SELECT id,
       project_id,
       creator_id,
       content,
       duration_ms,
       started_at,
       ended_at,
       entry_type,
       is_billable,
       created_at,
       updated_at
FROM entries
WHERE project_id = ?1
ORDER BY ended_at IS NULL,
         ended_at DESC,
         started_at DESC,
         created_at DESC
`

// Entries
func (q *Queries) ListEntriesByProject(ctx context.Context, projectID int64) ([]Entry, error) {
	rows, err := q.db.QueryContext(ctx, ListEntriesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CreatorID,
			&i.Content,
			&i.DurationMs,
			&i.StartedAt,
			&i.EndedAt,
			&i.EntryType,
			&i.IsBillable,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEntriesByTag = `-- name: ListEntriesByTag :many
SELECT e.id,
       e.project_id,
       e.creator_id,
       e.content,
       e.duration_ms,
       e.started_at,
       e.ended_at,
       e.entry_type,
       e.is_billable,
       e.created_at,
       e.updated_at
FROM entries e
JOIN entry_tags t ON t.entry_id = e.id
WHERE t.tag = ?1 COLLATE NOCASE
ORDER BY e.ended_at IS NULL,
         e.ended_at DESC,
         e.started_at DESC,
         e.created_at DESC
`

func (q *Queries) ListEntriesByTag(ctx context.Context, tag string) ([]Entry, error) {
	rows, err := q.db.QueryContext(ctx, ListEntriesByTag, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CreatorID,
			&i.Content,
			&i.DurationMs,
			&i.StartedAt,
			&i.EndedAt,
			&i.EntryType,
			&i.IsBillable,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProjects = `-- name: ListProjects :many

SELECT id,
       name,
       company,
       is_hidden,
       position,
       created_at,
       updated_at
FROM projects
ORDER BY position ASC,
         updated_at DESC
`

// Projects
func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, ListProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Company,
			&i.IsHidden,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTagsForEntry = `-- name: ListTagsForEntry :many

SELECT tag,
       created_at
FROM entry_tags
WHERE entry_id = ?1
ORDER BY tag
`

type ListTagsForEntryRow struct {
	Tag       string
	CreatedAt int64
}

// Entry Tags
func (q *Queries) ListTagsForEntry(ctx context.Context, entryID string) ([]ListTagsForEntryRow, error) {
	rows, err := q.db.QueryContext(ctx, ListTagsForEntry, entryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsForEntryRow
	for rows.Next() {
		var i ListTagsForEntryRow
		if err := rows.Scan(&i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListVisibleProjects = `-- name: ListVisibleProjects :many
SELECT id,
       name,
       company,
       is_hidden,
       position,
       created_at,
       updated_at
FROM projects
WHERE is_hidden = 0
ORDER BY position ASC,
         updated_at DESC
`

func (q *Queries) ListVisibleProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, ListVisibleProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Company,
			&i.IsHidden,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ProjectTotalsInRange = `-- name: ProjectTotalsInRange :one
SELECT COALESCE(SUM(duration_ms), 0) AS total_duration_ms,
       COALESCE(SUM(CASE WHEN is_billable = 1 THEN duration_ms ELSE 0 END), 0) AS billable_duration_ms,
       COUNT(*) AS entry_count
FROM entries
WHERE project_id = ?1
  AND ended_at IS NOT NULL
  AND ended_at >= ?2
  AND ended_at < ?3
`

type ProjectTotalsInRangeParams struct {
	ProjectID int64
	EndedAt   sql.NullInt64
	EndedAt_2 sql.NullInt64
}

type ProjectTotalsInRangeRow struct {
	TotalDurationMs    interface{}
	BillableDurationMs interface{}
	EntryCount         int64
}

func (q *Queries) ProjectTotalsInRange(ctx context.Context, arg ProjectTotalsInRangeParams) (ProjectTotalsInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, ProjectTotalsInRange, arg.ProjectID, arg.EndedAt, arg.EndedAt_2)
	var i ProjectTotalsInRangeRow
	err := row.Scan(&i.TotalDurationMs, &i.BillableDurationMs, &i.EntryCount)
	return i, err
}

const TouchProject = `-- name: TouchProject :exec
UPDATE projects
SET updated_at = unixepoch()
WHERE id = ?1
`

func (q *Queries) TouchProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, TouchProject, id)
	return err
}

const UpdateEntry = `-- name: UpdateEntry :one
UPDATE entries
SET project_id = ?2,
    creator_id = ?3,
    content = ?4,
    duration_ms = ?5,
    started_at = ?6,
    ended_at = ?7,
    entry_type = ?8,
    is_billable = ?9,
    updated_at = unixepoch()
WHERE id = ?1
RETURNING id,
          project_id,
          creator_id,
          content,
          duration_ms,
          started_at,
          ended_at,
          entry_type,
          is_billable,
          created_at,
          updated_at
`

type UpdateEntryParams struct {
	ID         string
	ProjectID  int64
	CreatorID  sql.NullInt64
	Content    string
	DurationMs int64
	StartedAt  sql.NullInt64
	EndedAt    sql.NullInt64
	EntryType  string
	IsBillable int64
}

func (q *Queries) UpdateEntry(ctx context.Context, arg UpdateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, UpdateEntry,
		arg.ID,
		arg.ProjectID,
		arg.CreatorID,
		arg.Content,
		arg.DurationMs,
		arg.StartedAt,
		arg.EndedAt,
		arg.EntryType,
		arg.IsBillable,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatorID,
		&i.Content,
		&i.DurationMs,
		&i.StartedAt,
		&i.EndedAt,
		&i.EntryType,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = ?2,
    company = ?3,
    is_hidden = ?4,
    updated_at = unixepoch()
WHERE id = ?1
RETURNING id,
          name,
          company,
          is_hidden,
          position,
          created_at,
          updated_at
`

type UpdateProjectParams struct {
	ID       int64
	Name     string
	Company  sql.NullString
	IsHidden int64
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, UpdateProject,
		arg.ID,
		arg.Name,
		arg.Company,
		arg.IsHidden,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.IsHidden,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpsertPerson = `-- name: UpsertPerson :one
INSERT INTO people (email, name)
VALUES (?1, ?2)
ON CONFLICT(email) DO UPDATE
SET name = excluded.name,
    updated_at = unixepoch()
RETURNING id,
          email,
          name,
          created_at,
          updated_at
`

type UpsertPersonParams struct {
	Email string
	Name  string
}

func (q *Queries) UpsertPerson(ctx context.Context, arg UpsertPersonParams) (Person, error) {
	row := q.db.QueryRowContext(ctx, UpsertPerson, arg.Email, arg.Name)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpsertTimer = `-- name: UpsertTimer :one
INSERT INTO timers (project_id, started_at)
VALUES (?1, ?2)
ON CONFLICT(project_id) DO UPDATE
SET started_at = excluded.started_at,
    updated_at = unixepoch()
RETURNING project_id,
          started_at,
          created_at,
          updated_at
`

type UpsertTimerParams struct {
	ProjectID int64
	StartedAt int64
}

func (q *Queries) UpsertTimer(ctx context.Context, arg UpsertTimerParams) (Timer, error) {
	row := q.db.QueryRowContext(ctx, UpsertTimer, arg.ProjectID, arg.StartedAt)
	var i Timer
	err := row.Scan(
		&i.ProjectID,
		&i.StartedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
